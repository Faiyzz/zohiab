// prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

/**
 * =========================
 * Core identity (UNCHANGED except where noted)
 * =========================
 */

enum UserType {
  ADMIN
  EMPLOYEE
  CLIENT
}

// --- User ---
model User {
  id       Int      @id @default(autoincrement())
  name     String
  email    String   @unique
  phone    String?
  password String
  isActive Boolean  @default(true)
  type     UserType @default(EMPLOYEE)

  // M:N with Role through UserRole
  roles UserRole[] @relation("UserToUserRole")

  employee Employee?
  client   Client?

  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  @@index([type])
}

// --- Role ---
model Role {
  id          Int     @id @default(autoincrement())
  name        String  @unique   // e.g., "SPM", "Team Lead", "PM", "Onboarding Manager"
  description String?
  isSystem    Boolean @default(false)

  userLinks UserRole[]       @relation("RoleToUserRole")
  permLinks RolePermission[] @relation("RoleToRolePermission")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// --- Permission ---
model Permission {
  id          Int     @id @default(autoincrement())
  resource    String             // e.g., "employee", "team", "project", "assignment_request"
  action      String             // e.g., "create","read","read_detail","update","delete","assign","approve"
  description String?
  isActive    Boolean @default(true)

  // Pair with RolePermission.permission
  roleLinks RolePermission[] @relation("PermToRolePermission")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([resource, action])
  @@index([resource, action])
}

// --- Join: Role <-> Permission ---
model RolePermission {
  id           Int @id @default(autoincrement())
  roleId       Int
  permissionId Int

  role       Role       @relation("RoleToRolePermission", fields: [roleId], references: [id], onDelete: Cascade)
  permission Permission @relation("PermToRolePermission", fields: [permissionId], references: [id], onDelete: Cascade)

  // OPTIONAL SCOPE (ABAC-lite): when you want to limit a permission to one entity instance.
  // Leave these NULL for global permission.
  resourceType String?  // e.g., "team" | "project" | "employee"
  resourceId   String?  // store as string to support UUIDs/ints

  @@unique([roleId, permissionId, resourceType, resourceId])
  @@index([roleId])
  @@index([permissionId])
}

// --- Join: User <-> Role (CHANGED: proficiency, isPrimary, assignedAt) ---
model UserRole {
  id           Int          @id @default(autoincrement())
  userId       Int
  roleId       Int
  proficiency  Proficiency? // e.g., Team Lead (ADVANCED)
  isPrimary    Boolean      @default(false)
  assignedAt   DateTime     @default(now())

  user User @relation("UserToUserRole", fields: [userId], references: [id], onDelete: Cascade)
  role Role @relation("RoleToUserRole", fields: [roleId], references: [id], onDelete: Cascade)

  @@unique([userId, roleId])
  @@index([userId])
  @@index([roleId])
}

/**
 * =========================
 * Client domain (UNCHANGED)
 * =========================
 */

model Client {
  id     Int  @id @default(autoincrement())
  userId Int  @unique
  user   User @relation(fields: [userId], references: [id], onDelete: Cascade)

  status      ClientStatus @default(NOT_ONBOARDED)
  greetedOnce Boolean      @default(false)

  submission ClientSubmission?         @relation("ClientToSubmission")
  packages   ClientPackageAssignment[]

  answers ClientAnswer[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([status])
}

enum ClientStatus {
  NOT_ONBOARDED
  ONBOARDED
  ACTIVE
  INACTIVE
  COMPLETED
  REFUNDED
}

model ClientSubmission {
  id               Int      @id @default(autoincrement())
  clientId         Int      @unique
  organizationName String
  purpose          String
  aboutYou         String
  assets           String
  createdAt        DateTime @default(now())

  client Client @relation("ClientToSubmission", fields: [clientId], references: [id], onDelete: Cascade)
}

model ClientPackageCategory {
  id       Int             @id @default(autoincrement())
  name     String          @unique
  packages ClientPackage[]
}

model ClientPackage {
  id             Int                       @id @default(autoincrement())
  name           String
  categoryId     Int
  category       ClientPackageCategory     @relation(fields: [categoryId], references: [id], onDelete: Restrict)
  expectedAmount Float
  assignments    ClientPackageAssignment[]
}

enum PackageStatus {
  IN_PROGRESS
  COMPLETED
}

model ClientPackageAssignment {
  id             Int           @id @default(autoincrement())
  clientId       Int
  packageId      Int
  amountPaid     Float         @default(0)
  expectedAmount Float
  status         PackageStatus @default(IN_PROGRESS)
  hosting        Boolean       @default(false)
  domain         String?
  hostingStart   DateTime?
  hostingEnd     DateTime?
  createdAt      DateTime      @default(now())

  client  Client        @relation(fields: [clientId], references: [id], onDelete: Cascade)
  package ClientPackage @relation(fields: [packageId], references: [id], onDelete: Restrict)
  addOns  AddOnAssignment[]

  @@index([clientId])
  @@index([packageId])
  @@index([status])
}

model AddOnAssignment {
  id                  Int   @id @default(autoincrement())
  addonId             Int
  packageAssignmentId Int
  amountPaid          Float @default(0)

  addon             AddOn                   @relation(fields: [addonId], references: [id], onDelete: Restrict)
  packageAssignment ClientPackageAssignment @relation(fields: [packageAssignmentId], references: [id], onDelete: Cascade)

  @@index([addonId])
  @@index([packageAssignmentId])
}

model AddOn {
  id    Int    @id @default(autoincrement())
  name  String @unique
  price Float

  assignments AddOnAssignment[]
}

/**
 * =========================
 * FORMS (UNCHANGED)
 * =========================
 */

model Form {
  id        Int      @id @default(autoincrement())
  name      String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  questionTypes QuestionType[]

  @@unique([name])
}

model QuestionType {
  id     Int    @id @default(autoincrement())
  name   String
  formId Int
  form   Form   @relation(fields: [formId], references: [id], onDelete: Cascade)

  questions Question[]

  @@index([formId])
}

model Question {
  id                   Int          @id @default(autoincrement())
  name                 String       @db.Text
  allowMultipleOptions Boolean      @default(false)
  responseType         ResponseType @default(TEXT)

  questionTypeId Int
  questionType   QuestionType @relation(fields: [questionTypeId], references: [id], onDelete: Cascade)

  options Option[]
  answers ClientAnswer[]

  @@index([questionTypeId])
}

model Option {
  id         Int        @id @default(autoincrement())
  text       String
  optionType OptionType @default(TEXT)

  questionId Int
  question   Question @relation(fields: [questionId], references: [id], onDelete: Cascade)

  @@index([questionId])
}

enum ResponseType {
  TEXT
  OPTION
  MULTI_COLOR
}

enum OptionType {
  TEXT
  URL
}

model ClientAnswer {
  id         Int      @id @default(autoincrement())
  clientId   Int
  questionId Int
  text       String?  @db.Text
  createdAt  DateTime @default(now())
  meta       Json?

  client   Client   @relation(fields: [clientId], references: [id], onDelete: Cascade)
  question Question @relation(fields: [questionId], references: [id], onDelete: Cascade)

  @@unique([clientId, questionId, text])
  @@index([clientId])
  @@index([questionId])
}

/**
 * =========================
 * Employee domain (UNCHANGED + minor)
 * =========================
 */

model Employee {
  id     Int  @id @default(autoincrement())
  userId Int  @unique
  user   User @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Org structure
  reportsToId Int?
  reportsTo   Employee?  @relation("Reports", fields: [reportsToId], references: [id])
  teamMembers Employee[] @relation("Reports")

  // Skills & ranks & payroll
  skills   EmployeeSkill[]
  ranks    EmployeeRank[]
  payments PayRoll[]

  isActive Boolean @default(true)

  // NEW: quick lookup to see if this employee is an SPM (derived in app OR via a primary role)
  // Not strictly required; you can compute it by joins. Kept nullable for flexibility.
  primaryRoleId Int?
  primaryRole   Role? @relation(fields: [primaryRoleId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([primaryRoleId])
}

model Skills {
  id        Int             @id @default(autoincrement())
  name      String          @unique
  employees EmployeeSkill[]
}

enum Proficiency {
  BEGINNER
  INTERMEDIATE
  PROFICIENT
  ADVANCED
  EXPERT
}

model EmployeeSkill {
  id          Int         @id @default(autoincrement())
  skillId     Int
  employeeId  Int
  proficiency Proficiency

  skill    Skills   @relation(fields: [skillId], references: [id], onDelete: Restrict)
  employee Employee @relation(fields: [employeeId], references: [id], onDelete: Cascade)

  @@unique([employeeId, skillId])
  @@index([skillId])
  @@index([employeeId])
}

model Rank {
  id          Int            @id @default(autoincrement())
  name        String         @unique
  baseSalary  Decimal        @db.Decimal(12, 2)
  description String?
  employees   EmployeeRank[]
}

model EmployeeRank {
  id            Int       @id @default(autoincrement())
  employeeId    Int
  rankId        Int
  effectiveFrom DateTime
  effectiveTo   DateTime?

  rank     Rank     @relation(fields: [rankId], references: [id], onDelete: Restrict)
  employee Employee @relation(fields: [employeeId], references: [id], onDelete: Cascade)

  @@index([employeeId])
  @@index([rankId])
}

/**
 * ===== Payroll (UNCHANGED)
 */
enum PayrollStatus {
  PENDING
  DUE
  PROCESSING
  PARTIAL
  PAID
  FAILED
  CANCELED
}

enum AdjustmentType {
  ALLOWANCE
  DEDUCTION
}

model PayRollType {
  id          Int       @id @default(autoincrement())
  name        String    @unique
  description String?
  payrolls    PayRoll[]
}

model PayRoll {
  id            Int @id @default(autoincrement())
  employeeId    Int
  payrollTypeId Int

  periodStart DateTime
  periodEnd   DateTime

  grossAmount Decimal @db.Decimal(12, 2)
  currency    String  @default("PKR")

  status    PayrollStatus @default(PENDING)
  dueDate   DateTime?
  paidAt    DateTime?
  reference String?
  note      String?

  employee    Employee            @relation(fields: [employeeId], references: [id], onDelete: Cascade)
  payrollType PayRollType         @relation(fields: [payrollTypeId], references: [id], onDelete: Restrict)
  adjustments PayrollAdjustment[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([employeeId])
  @@index([status])
  @@index([periodStart, periodEnd])
  @@index([dueDate])
}

model PayrollAdjustment {
  id        Int            @id @default(autoincrement())
  payrollId Int
  label     String
  type      AdjustmentType
  amount    Decimal        @db.Decimal(12, 2)

  payroll PayRoll @relation(fields: [payrollId], references: [id], onDelete: Cascade)

  @@index([payrollId])
}

/**
 * =========================
 * *** NEW *** Teams, Projects, Assignments & Requests
 * =========================
 */

// A lightweight org unit to group people working together.
// Example teams: "Portal Build – Client X", "Video Editing Crew A".
model Team {
  id          Int       @id @default(autoincrement())
  name        String
  description String?
  // Typically the Team Lead
  leaderId Int?
  leader   Employee? @relation("TeamLeader", fields: [leaderId], references: [id])

  members TeamMembership[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([name])
  @@index([leaderId])
}

enum TeamRole {
  TEAM_LEAD
  MEMBER
}

model TeamMembership {
  id         Int       @id @default(autoincrement())
  teamId     Int
  employeeId Int
  role       TeamRole  @default(MEMBER)
  joinedAt   DateTime  @default(now())
  leftAt     DateTime?

  team     Team     @relation(fields: [teamId], references: [id], onDelete: Cascade)
  employee Employee @relation(fields: [employeeId], references: [id], onDelete: Cascade)

  @@unique([teamId, employeeId])
  @@index([teamId])
  @@index([employeeId])
}

// Your “work container” that mirrors Taiga projects/epics.
// We DO NOT store tasks; only the external identifiers and metadata.
model Project {
  id             Int       @id @default(autoincrement())
  name           String
  clientId       Int?
  client         Client?   @relation(fields: [clientId], references: [id], onDelete: SetNull)
  externalId     String?   // Taiga project/epic ID
  externalSpace  String?   // e.g., "taiga"
  status         String?   // "active","on_hold","archived" (free text; keep flexible)
  description    String?

  assignments ProjectAssignment[]
  teams       ProjectTeam[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([clientId])
  @@index([externalId])
}

enum ProjectRole {
  SPM
  PM
  TEAM_LEAD
  MEMBER
  QA
}

model ProjectAssignment {
  id          Int         @id @default(autoincrement())
  projectId   Int
  employeeId  Int
  role        ProjectRole
  assignedAt  DateTime    @default(now())
  unassignedAt DateTime?

  project  Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)
  employee Employee @relation(fields: [employeeId], references: [id], onDelete: Cascade)

  @@index([projectId])
  @@index([employeeId])
  @@index([role])
  @@unique([projectId, employeeId, role])
}

// Optional: attach whole Teams to Projects.
model ProjectTeam {
  id        Int      @id @default(autoincrement())
  projectId Int
  teamId    Int
  addedAt   DateTime @default(now())

  project Project @relation(fields: [projectId], references: [id], onDelete: Cascade)
  team    Team    @relation(fields: [teamId], references: [id], onDelete: Cascade)

  @@unique([projectId, teamId])
  @@index([projectId])
  @@index([teamId])
}

// When a Team Lead needs more people, they file a request.
// SPM/Admin can approve/deny and specify who to add.
enum RequestStatus {
  PENDING
  APPROVED
  DENIED
  CANCELED
}

model AssignmentRequest {
  id             Int           @id @default(autoincrement())
  projectId      Int
  teamId         Int
  requestedById  Int           // Team Lead (employee)
  status         RequestStatus @default(PENDING)
  notes          String?
  createdAt      DateTime      @default(now())
  decidedAt      DateTime?

  project     Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)
  team        Team     @relation(fields: [teamId], references: [id], onDelete: Cascade)
  requestedBy Employee @relation(fields: [requestedById], references: [id], onDelete: Restrict)

  // Skills / headcount requested (1:N)
  needs AssignmentRequestNeed[]
  // Decision records (usually 1, but we allow history)
  decisions AssignmentDecision[]

  @@index([projectId])
  @@index([teamId])
  @@index([requestedById])
  @@index([status])
}

// Structured “need” a TL is asking for (e.g., 2 Web Dev (ADVANCED)).
model AssignmentRequestNeed {
  id           Int          @id @default(autoincrement())
  requestId    Int
  skillId      Int?         // optional, or use roleId instead
  roleId       Int?         // optional, if you want role-based headcount
  proficiency  Proficiency?
  headcount    Int          @default(1)
  notes        String?

  request AssignmentRequest @relation(fields: [requestId], references: [id], onDelete: Cascade)
  skill   Skills?          @relation(fields: [skillId], references: [id], onDelete: SetNull)
  role    Role?            @relation(fields: [roleId], references: [id], onDelete: SetNull)

  @@index([requestId])
  @@index([skillId])
  @@index([roleId])
}

// Decision + the actual people assigned in response.
model AssignmentDecision {
  id           Int           @id @default(autoincrement())
  requestId    Int
  decidedById  Int           // SPM/Admin (employee)
  decision     RequestStatus // APPROVED or DENIED typically
  reason       String?
  createdAt    DateTime      @default(now())

  request   AssignmentRequest @relation(fields: [requestId], references: [id], onDelete: Cascade)
  decidedBy Employee          @relation(fields: [decidedById], references: [id], onDelete: Restrict)

  // Which employees were added due to this decision
  addedEmployees DecisionAddedEmployee[]

  @@index([requestId])
  @@index([decidedById])
}

model DecisionAddedEmployee {
  id          Int               @id @default(autoincrement())
  decisionId  Int
  employeeId  Int
  projectRole ProjectRole       @default(MEMBER)

  decision AssignmentDecision @relation(fields: [decisionId], references: [id], onDelete: Cascade)
  employee Employee           @relation(fields: [employeeId], references: [id], onDelete: Restrict)

  @@unique([decisionId, employeeId])
  @@index([employeeId])
}

/**
 * =========================
 * Optional: Audit trail & explicit access grants
 * =========================
 */

// Simple audit log you can write to from your services.
model AuditLog {
  id        Int      @id @default(autoincrement())
  actorId   Int?
  actorType String?  // "user" | "system" | "cron"
  action    String   // free text or a verb like "ASSIGN_TEAM_MEMBER"
  target    String?  // "project:123", "employee:45"
  meta      Json?
  createdAt DateTime @default(now())

  actor User? @relation(fields: [actorId], references: [id], onDelete: SetNull)

  @@index([actorId])
  @@index([createdAt])
}

// Per-user overrides beyond role permissions (rare but useful).
model AccessGrant {
  id           Int      @id @default(autoincrement())
  userId       Int
  resourceType String   // "employee" | "team" | "project" | ...
  resourceId   String   // stringified id
  action       String   // "read_detail" | "assign" | ...
  expiresAt    DateTime?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, resourceType, resourceId, action])
  @@index([userId])
}
